######################################################################
#
# sample_colors.py
# 
# Written for ENGR 028/CPSC 082: Mobile Robotics, Summer 2020
# Copyright (C) Matt Zucker 2020
#
######################################################################

import color_blob_detector as blob

import cv2
import json
import sys
import os
import numpy as np

WINDOW = 'Color picker'

def rotate(cnt, idx, delta):
    return (idx + delta + cnt) % cnt

class ColorPickerApp:

    def __init__(self, filenames):

        self.script_dir = os.path.dirname(os.path.abspath(__file__))

        self.detector = blob.ColorBlobDetector(mode='bgr')
        
        self.json_filename = os.path.join(self.script_dir, 'sample_data.json')

        with open(self.json_filename, 'r') as istr:
            cdata = blob.numpy_from_json(json.load(istr))

        self.image_samples = cdata['image_samples_ycrcb']

        self.ycrcb_threshold = np.array([ 30, 15, 15 ], dtype=np.uint8)
        self.min_box_size = np.array([ 15, 7, 7 ], dtype=np.uint8 )
        
        self.filenames = filenames
        self.file_index = 0
        self.color_index = 0

        self.cur_filename = None
        self.cur_image = None
        self.cur_ycrcb = None

        self.display = None

        print(self.detector.all_bboxes)

        self.recompute_detector()

        print(self.detector.all_bboxes)

        cv2.namedWindow(WINDOW)
        cv2.setMouseCallback(WINDOW, self.mouse)

    def update_detector(self, filename, color_index, sample_bbox, force=False):

        orig_bbox = self.detector.all_bboxes[color_index]
        new_bbox = blob.union(orig_bbox, sample_bbox)

        is_ok = True

        for other_color_index in range(self.detector.num_colors):
            
            if other_color_index == color_index:
                continue
            
            other_bbox = self.detector.all_bboxes[other_color_index]

            orig_intersection = blob.intersection(orig_bbox, other_bbox)
            new_intersection = blob.intersection(new_bbox, other_bbox)
            
            if orig_intersection is None and new_intersection is not None:

                color_name = self.detector.color_names[color_index]
                other_color_name = self.detector.color_names[other_color_index]
                
                print('WARNING: updating {} for image {}:'.format(
                    color_name, filename))
                print('  color {} would overlap color {}'.format(
                    color_name, other_color_name))
                print('  {} bbox: {}-{}'.format(color_name, new_bbox[0], new_bbox[1]))
                print('  {} bbox: {}-{}'.format(other_color_name, other_bbox[0], other_bbox[1]))
                if not force:
                    return False
                else:
                    is_ok = False

        self.detector.all_bboxes[color_index] = new_bbox
        return is_ok

    def recompute_detector(self):

        orig_all_bboxes = self.detector.all_bboxes
        
        self.detector.all_bboxes = [ None ] * self.detector.num_colors

        is_ok = True

        for filename, image_samples in self.image_samples.items():
            for color_index, color_name in enumerate(self.detector.color_names):
                if color_name in image_samples:
                    update_ok = self.update_detector(filename,
                                                     color_index,
                                                     image_samples[color_name],
                                                     force=True)
                    if not update_ok:
                        is_ok = False

        for color_name, bbox in zip(self.detector.color_names, self.detector.all_bboxes):
            
            if bbox is None:
                print('WARNING: no samples for color {}!'.format(color_name))
                is_ok = False
                continue
            
            brng = bbox[1] - bbox[0] + 1
            toosmall = brng < self.min_box_size

            if np.any(toosmall):
                print('INFO: expanding range for {} from {} to {}'.format(
                    color_name, brng, self.min_box_size))
                bmid = (bbox[0].astype(int) + bbox[1].astype(int)) // 2
                brad = self.min_box_size // 2
                bbox[0, toosmall] = bmid - brad
                bbox[1, toosmall] = bmid + brad

        if not is_ok:
            self.detector.all_bboxes = orig_all_bboxes
            return

        self.detector.all_bboxes = np.array(self.detector.all_bboxes, dtype=np.uint8)
        self.detector.update_palette()

    def save_detector(self):

        config_filename = os.path.join(self.script_dir,
                                       'color_definitions_autogenerated.json')
        
        self.detector.save(config_filename)
                
    def sample_color(self, x, y):

        assert self.cur_filename is not None
        assert self.color_index in range(self.detector.num_colors)

        init_color = self.cur_ycrcb[y,x].astype(np.int32)

        queue = [(x, y, init_color)]
        samples = []

        h, w = self.cur_ycrcb.shape[:2]
        covered = np.zeros((h, w), dtype=bool)
        covered[y, x] = True

        while len(queue):

            x, y, cur_color = queue.pop(0)
            samples.append(cur_color)
            assert covered[y, x]

            for dx, dy in [(-1, 0), (0, -1), (1, 0), (0, 1)]:
                nx = x + dx
                ny = y + dy
                if nx >= 0 and ny >= 0 and nx < w and ny < h and not covered[ny, nx]:
                    covered[ny, nx] = True
                    next_color = self.cur_ycrcb[ny,nx].astype(np.int32)
                    delta = np.abs(cur_color - next_color).max()
                    if not(np.any(delta > self.ycrcb_threshold)):
                        queue.append((nx, ny, next_color))

        samples = np.array(samples, dtype=np.uint8)
        sample_bbox = np.array([samples.min(axis=0), samples.max(axis=0)], dtype=np.uint8)

        can_add = self.update_detector(self.cur_filename,
                                       self.color_index,
                                       sample_bbox, force=False)

        if not can_add:
            return

        if self.cur_filename not in self.image_samples:
            self.image_samples[self.cur_filename] = dict()

        cur_file_samples = self.image_samples[self.cur_filename]
        color_name = self.detector.color_names[self.color_index]

        if color_name not in cur_file_samples:
            cur_file_samples[color_name] = sample_bbox
        else:
            cur_file_samples[color_name] = blob.union(
                cur_file_samples[color_name],
                sample_bbox)
            
        self.render()

    def mouse(self, event, x, y, flags, param):

        if event == cv2.EVENT_LBUTTONDOWN:
            if self.color_index in range(self.detector.num_colors):
                self.sample_color(x, y)
        
    def render(self):

        while self.cur_image is None:
            self.cur_image = cv2.imread(self.filenames[self.file_index])
            if self.cur_image is not None:
                self.cur_filename = os.path.relpath(
                    self.filenames[self.file_index], self.script_dir)
                self.cur_ycrcb = self.detector.convert_to_ycrcb(self.cur_image)
                self.checkers = None
                break
            self.filenames.pop(self.file_index)

        h, w = self.cur_image.shape[:2]

        if self.checkers is None:
            u, v = np.meshgrid(np.arange(w), np.arange(h))
            self.checkers = (u % 2 == 0) ^ (v % 2 == 0)


        self.display = self.cur_image.copy()

        text = [
            'File: ' + self.cur_filename,
        ]
        
        if self.color_index < self.detector.num_colors:
            
            color_name = self.detector.color_names[self.color_index]
            
            print('rendering image {} color {}'.format(
                self.cur_filename, color_name))

            mask = None

            if self.cur_filename in self.image_samples:
                cur_file_samples = self.image_samples[self.cur_filename]
                if color_name in cur_file_samples:
                    bbox = cur_file_samples[color_name]
                    mask = blob.get_mask(bbox, self.cur_ycrcb)

            if mask is None:
                mask = np.zeros((h, w), dtype=np.uint8)
                
            redme = ~mask.view(bool) & self.checkers
            self.display[redme] = self.display[redme] // 4 + [191, 191, 191]

            text.append('Color: ' + color_name)

        elif self.color_index == self.detector.num_colors:

            text.append('Original image')

        else:

            text.append('Labeled image')
            labels = self.detector.label_image(self.cur_ycrcb)

            self.display = self.detector.colorize_labels(labels)

        dy = 20

        for thickness, cval in [(3, 0), (1, 255)]:
            color = (cval, cval, cval)
            y = 18
            for line in text:
                cv2.putText(self.display, line, (4, y),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5,
                            color, thickness, cv2.LINE_AA)
                y += dy

        cv2.imshow(WINDOW, self.display)

        self.need_render = False

    def run(self):

        while True:

            if self.cur_image is None:
                self.need_render = True

            if self.need_render:
                self.render()

            while True:
                try:
                    k = cv2.waitKey(5)
                    if k != 0:
                        break
                except KeyboardInterrupt:
                    sys.exit(0)
                    break

            if k == 27:
                break
            elif k == ord(']'):
                self.file_index = rotate(len(self.filenames), self.file_index, 1)
                self.cur_image = None
            elif k == ord('['):
                self.file_index = rotate(len(self.filenames), self.file_index, -1)
                self.cur_image = None
            elif k == ord('.') or k == ord('>'):
                self.color_index = rotate(self.detector.num_colors+2, self.color_index, 1)
                self.need_render = True
            elif k == ord(',') or k == ord('<'):
                self.color_index = rotate(self.detector.num_colors+2, self.color_index, -1)
                self.need_render = True

    def save_samples(self):

        cdata = blob.json_from_numpy(
            dict(image_samples_ycrcb=self.image_samples))

        encoded = blob.json_encode(cdata)

        with open(self.json_filename, 'w') as ostr:
            ostr.write(encoded)
            ostr.write('\n')

        print('wrote', self.json_filename)

def main():

    filenames = sys.argv[1:]

    app = ColorPickerApp(filenames)
    app.run()

    app.save_samples()
    app.save_detector()

    
if __name__ == '__main__':
    main()
